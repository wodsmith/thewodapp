import "server-only"

import { asc, desc, eq, inArray } from "drizzle-orm"
import { getDd } from "@/db"
import {
	programmingTracksTable,
	scalingGroupsTable,
	scalingLevelsTable,
	TEAM_PERMISSIONS,
	teamTable,
} from "@/db/schema"
import { requireTeamPermission } from "@/utils/team-auth"

export interface CreateScalingGroupInput {
	teamId: string | null
	title: string
	description?: string | null
	isDefault?: boolean
}

export interface UpdateScalingGroupInput {
	title?: string
	description?: string | null
	isDefault?: boolean
}

export async function createScalingGroup({
	teamId,
	title,
	description,
	isDefault,
}: CreateScalingGroupInput) {
	const db = getDd()

	if (teamId) {
		await requireTeamPermission(teamId, TEAM_PERMISSIONS.EDIT_TEAM_SETTINGS)
	}

	const [created] = await db
		.insert(scalingGroupsTable)
		.values({
			// id autogenerated by schema
			title,
			description: description ?? null,
			teamId: teamId ?? null,
			isDefault: isDefault ? 1 : 0,
			// timestamps are defaulted by commonColumns
		})
		.returning()

	return created
}

export async function updateScalingGroup({
	teamId,
	scalingGroupId,
	data,
}: {
	teamId: string | null
	scalingGroupId: string
	data: UpdateScalingGroupInput
}) {
	const db = getDd()

	if (teamId) {
		await requireTeamPermission(teamId, TEAM_PERMISSIONS.EDIT_TEAM_SETTINGS)
	}

	const [existing] = await db
		.select()
		.from(scalingGroupsTable)
		.where(eq(scalingGroupsTable.id, scalingGroupId))

	if (!existing) return null

	// If this is a team-owned group, enforce same team
	if (existing.teamId && teamId && existing.teamId !== teamId) return null

	const [updated] = await db
		.update(scalingGroupsTable)
		.set({
			title: data.title ?? existing.title,
			description:
				data.description === undefined
					? existing.description
					: data.description,
			isDefault:
				data.isDefault === undefined
					? existing.isDefault
					: data.isDefault
						? 1
						: 0,
			updatedAt: new Date(),
		})
		.where(eq(scalingGroupsTable.id, scalingGroupId))
		.returning()

	return updated
}

export async function deleteScalingGroup({
	teamId,
	scalingGroupId,
}: {
	teamId: string | null
	scalingGroupId: string
}) {
	const db = getDd()

	if (teamId) {
		await requireTeamPermission(teamId, TEAM_PERMISSIONS.EDIT_TEAM_SETTINGS)
	}

	const [existing] = await db
		.select()
		.from(scalingGroupsTable)
		.where(eq(scalingGroupsTable.id, scalingGroupId))

	if (!existing) return { success: true }

	if (existing.isSystem === 1) {
		return { success: false, error: "System scaling groups cannot be deleted" }
	}

	if (existing.teamId && teamId && existing.teamId !== teamId) {
		return { success: false, error: "Forbidden" }
	}

	await db
		.delete(scalingGroupsTable)
		.where(eq(scalingGroupsTable.id, scalingGroupId))
	return { success: true }
}

export async function listScalingGroups({
	teamId,
	includeSystem = true,
}: {
	teamId: string
	includeSystem?: boolean
}) {
	const db = getDd()
	await requireTeamPermission(teamId, TEAM_PERMISSIONS.ACCESS_DASHBOARD)

	const rows = await db
		.select()
		.from(scalingGroupsTable)
		.where(
			includeSystem
				? inArray(scalingGroupsTable.teamId, [teamId, null as any])
				: eq(scalingGroupsTable.teamId, teamId),
		)
		.orderBy(desc(scalingGroupsTable.isSystem), asc(scalingGroupsTable.title))

	// Fetch levels for each group
	const groupsWithLevels = await Promise.all(
		rows.map(async (group) => {
			const levels = await db
				.select()
				.from(scalingLevelsTable)
				.where(eq(scalingLevelsTable.scalingGroupId, group.id))
				.orderBy(asc(scalingLevelsTable.position))

			return {
				...group,
				levels,
			}
		}),
	)

	return groupsWithLevels
}

export async function getScalingGroupWithLevels({
	teamId: _teamId, // Kept for API compatibility but not used for read operations
	scalingGroupId,
}: {
	teamId: string | null
	scalingGroupId: string
}) {
	const db = getDd()

	const [group] = await db
		.select()
		.from(scalingGroupsTable)
		.where(eq(scalingGroupsTable.id, scalingGroupId))

	if (!group) return null

	// Allow fetching scaling groups from other teams when reading (not modifying)
	// This is needed for logging results on workouts from other teams that have scaling groups
	// The team check should be done at the action level if needed for modification operations

	const levels = await db
		.select()
		.from(scalingLevelsTable)
		.where(eq(scalingLevelsTable.scalingGroupId, scalingGroupId))
		.orderBy(asc(scalingLevelsTable.position))

	return { ...group, levels }
}

export async function assignScalingGroupToTrack({
	teamId,
	trackId,
	scalingGroupId,
}: {
	teamId: string
	trackId: string
	scalingGroupId: string | null
}) {
	const db = getDd()
	await requireTeamPermission(teamId, TEAM_PERMISSIONS.MANAGE_PROGRAMMING)

	// Verify track belongs to team (ownerTeamId) or team has permission to edit
	const [track] = await db
		.select()
		.from(programmingTracksTable)
		.where(eq(programmingTracksTable.id, trackId))

	if (!track) return { success: false, error: "Track not found" }

	// If setting a group, it must either be system or owned by same team
	if (scalingGroupId) {
		const [group] = await db
			.select({
				id: scalingGroupsTable.id,
				teamId: scalingGroupsTable.teamId,
				isSystem: scalingGroupsTable.isSystem,
			})
			.from(scalingGroupsTable)
			.where(eq(scalingGroupsTable.id, scalingGroupId))

		if (!group) return { success: false, error: "Scaling group not found" }

		if (group.teamId && group.teamId !== track.ownerTeamId) {
			return {
				success: false,
				error: "Scaling group not accessible for this track",
			}
		}
	}

	const [updated] = await db
		.update(programmingTracksTable)
		.set({ scalingGroupId: scalingGroupId ?? null, updatedAt: new Date() })
		.where(eq(programmingTracksTable.id, trackId))
		.returning()

	return { success: true, track: updated }
}

export async function setTeamDefaultScalingGroup({
	teamId,
	scalingGroupId,
}: {
	teamId: string
	scalingGroupId: string
}) {
	const db = getDd()
	await requireTeamPermission(teamId, TEAM_PERMISSIONS.EDIT_TEAM_SETTINGS)

	// Validate group ownership or system
	const [group] = await db
		.select()
		.from(scalingGroupsTable)
		.where(eq(scalingGroupsTable.id, scalingGroupId))

	if (!group) return { success: false, error: "Scaling group not found" }
	if (group.teamId && group.teamId !== teamId) {
		return { success: false, error: "Forbidden" }
	}

	const [team] = await db
		.update(teamTable)
		.set({ defaultScalingGroupId: scalingGroupId, updatedAt: new Date() })
		.where(eq(teamTable.id, teamId))
		.returning()

	// Mark this group as default for this team (non-authoritative but useful)
	await db
		.update(scalingGroupsTable)
		.set({ isDefault: 1, updatedAt: new Date() })
		.where(eq(scalingGroupsTable.id, scalingGroupId))

	return { success: true, team }
}
